-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package flock-pieces-functor-constraint
@version 0.1.0.0

module Data.Functor.Constraint.Wrap

-- | A wrapper type where the first argument is a given constraint on the
--   value.
data WrapC c a
[WrapC] :: c a => a -> WrapC c a

-- | No <a>Functor</a> instance for <a>WrapC</a>, the constraints won't
--   allow it
wmap :: c b => (a -> b) -> WrapC c a -> WrapC c b

-- | Variant of <tt>c a =&gt; a -&gt; _ c a</tt>, apply constraint
--   differently
--   
--   <pre>
--   resolveE :: P c (E c) -&gt; P c (E ())
--   </pre>
data WrapE c a
[WrapE] :: c (WrapE c) => a -> WrapE c a

-- | Variant of <tt>c a =&gt; a -&gt; _ c a</tt>, no value
--   
--   <pre>
--   resolveE :: P c (E c) -&gt; P c (E ())
--   
--   
--   • Could not deduce: c b arising from a use of ‘P’
--     from the context: c a
--       bound by a pattern with constructor:
--                  P :: forall (c :: * -&gt; Constraint) a. c a =&gt; Proxy a -&gt; P c a,
--                in an equation for ‘fmap’
--       at <i>Users</i>michaelklein<i>Desktop</i>flock<i>pieces</i>through<i>src</i>Scratch/Hs4.hs:1458:11-13
--   • In the expression: P (fmap f x)
--     In an equation for ‘fmap’: fmap f (P x) = P (fmap f x)
--     In the instance declaration for ‘Functor (P c)’
--   
--   instance Functor (P c) where
--     fmap f (P x) = P (fmap f x)
--   </pre>
data WrapP c a
[WrapP] :: c a => Proxy a -> WrapP c a

-- | No <a>Functor</a> instance for <a>WrapP</a>, the constraints won't
--   allow it
pmap :: c b => (a -> b) -> WrapP c a -> WrapP c b
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Constraint.Wrap.WrapC GHC.Show.Show a)
instance GHC.Base.Functor (Data.Functor.Constraint.Wrap.WrapE c)

module Data.Functor.Constraint.Jop

-- | Like <tt>Op</tt>, but holds the values, is a <a>Functor</a>, etc
newtype Jop a b
Jop :: (b, (b -> a) -> a) -> Jop a b
[runJop] :: Jop a b -> (b, (b -> a) -> a)

-- | Make a <a>Jop</a>
mkJop :: b -> Jop a b

-- | Apply the inner function to the given function
extractJopL :: (b -> a) -> Jop a b -> a

-- | Extract the return value from <a>Jop</a>
extractJopR :: Jop a b -> b
instance GHC.Classes.Eq b => GHC.Classes.Eq (Data.Functor.Constraint.Jop.Jop a b)
instance GHC.Classes.Ord b => GHC.Classes.Ord (Data.Functor.Constraint.Jop.Jop a b)
instance GHC.Show.Show b => GHC.Show.Show (Data.Functor.Constraint.Jop.Jop a b)
instance GHC.Base.Functor (Data.Functor.Constraint.Jop.Jop a)

module Data.Functor.Constraint.Const

-- | Pass <a>Void</a> to <tt>c</tt>, guaranteeing the first arg is unused
newtype ConstC c a
ConstC :: c Void a -> ConstC c a
[getConstC] :: ConstC c a -> c Void a

-- | Extract first

-- | Extract first

-- | Extract first

-- | Map inside
instance GHC.Classes.Eq (c Data.Void.Void a) => GHC.Classes.Eq (Data.Functor.Constraint.Const.ConstC c a)
instance GHC.Classes.Ord (c Data.Void.Void a) => GHC.Classes.Ord (Data.Functor.Constraint.Const.ConstC c a)
instance GHC.Show.Show (c Data.Void.Void a) => GHC.Show.Show (Data.Functor.Constraint.Const.ConstC c a)
instance GHC.Base.Functor (c Data.Void.Void) => GHC.Base.Functor (Data.Functor.Constraint.Const.ConstC c)

module Data.Functor.Constraint

-- | Pass <a>Void</a> to <tt>c</tt>, guaranteeing the first arg is unused
newtype ConstC c a
ConstC :: c Void a -> ConstC c a
[getConstC] :: ConstC c a -> c Void a

-- | Like <tt>Op</tt>, but holds the values, is a <a>Functor</a>, etc
newtype Jop a b
Jop :: (b, (b -> a) -> a) -> Jop a b
[runJop] :: Jop a b -> (b, (b -> a) -> a)

-- | Make a <a>Jop</a>
mkJop :: b -> Jop a b

-- | Apply the inner function to the given function
extractJopL :: (b -> a) -> Jop a b -> a

-- | Extract the return value from <a>Jop</a>
extractJopR :: Jop a b -> b

-- | A wrapper type where the first argument is a given constraint on the
--   value.
data WrapC c a
[WrapC] :: c a => a -> WrapC c a

-- | No <a>Functor</a> instance for <a>WrapC</a>, the constraints won't
--   allow it
wmap :: c b => (a -> b) -> WrapC c a -> WrapC c b

-- | Variant of <tt>c a =&gt; a -&gt; _ c a</tt>, apply constraint
--   differently
--   
--   <pre>
--   resolveE :: P c (E c) -&gt; P c (E ())
--   </pre>
data WrapE c a
[WrapE] :: c (WrapE c) => a -> WrapE c a

-- | Variant of <tt>c a =&gt; a -&gt; _ c a</tt>, no value
--   
--   <pre>
--   resolveE :: P c (E c) -&gt; P c (E ())
--   
--   
--   • Could not deduce: c b arising from a use of ‘P’
--     from the context: c a
--       bound by a pattern with constructor:
--                  P :: forall (c :: * -&gt; Constraint) a. c a =&gt; Proxy a -&gt; P c a,
--                in an equation for ‘fmap’
--       at <i>Users</i>michaelklein<i>Desktop</i>flock<i>pieces</i>through<i>src</i>Scratch/Hs4.hs:1458:11-13
--   • In the expression: P (fmap f x)
--     In an equation for ‘fmap’: fmap f (P x) = P (fmap f x)
--     In the instance declaration for ‘Functor (P c)’
--   
--   instance Functor (P c) where
--     fmap f (P x) = P (fmap f x)
--   </pre>
data WrapP c a
[WrapP] :: c a => Proxy a -> WrapP c a

-- | No <a>Functor</a> instance for <a>WrapP</a>, the constraints won't
--   allow it
pmap :: c b => (a -> b) -> WrapP c a -> WrapP c b
